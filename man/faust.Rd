% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/faust.R, R/zzz.R
\docType{package}
\name{faust}
\alias{faust}
\title{Full Annotation Using Shape-constrained Trees}
\usage{
faust(
  gatingSet,
  startingCellPop,
  activeChannels = flowWorkspace::markernames(gatingSet),
  channelBounds = "",
  experimentalUnit = "",
  imputationHierarchy = "",
  projectPath = normalizePath("."),
  depthScoreThreshold = 0.01,
  selectionQuantile = 0.5,
  nameOccuranceNum = 0,
  supervisedList = NA,
  debugFlag = FALSE,
  threadNum = 1,
  seedValue = 123,
  drawAnnotationHistograms = TRUE,
  annotationsApproved = FALSE,
  densitySubSampleThreshold = 1e+06,
  densitySubSampleSize = 1e+06,
  densitySubSampleIterations = 1,
  archDescriptionList = list(targetArch = c("singleCPU")),
  plottingDevice = "pdf"
)
}
\arguments{
\item{gatingSet}{The FAUST method requires that experimental cytometry
data you wish to analyze is stored in a \code{GatingSet} data structure. This data
structure can be constructed available using the \code{flowWorkspace} Bioconductor
package.}

\item{startingCellPop}{A character vector specifying the node from the manual
gating strategy attached to the \code{gatingSet} to use for \code{faust} analysis. The
node in the manual gating strategy is, at minimum, asusmed by \code{faust} to have
pre-gated debris and dead cells. For example, the node might identify live
lymphocytes in each sample.}

\item{activeChannels}{A character vector, each entry of which is a marker name
to be used in the \code{faust} analysis. The markers listed in this parameter must
\strong{exactly} match the \code{desc} field of the \code{parameters} of the \code{flowFrames} in
the \code{GatingSet. }FAUST` will not run if they do not match exactly.}

\item{channelBounds}{This parameter accepts three settings: an empty string,
a matrix, and a list.

The matrix setting: A 2 by \code{length(activeChannels)} numeric matrix, with
\code{colnames(channelBounds) <- activeChannels} and
\code{rownames(channelBounds) <- c("Low","High")}. Expression values in a channel
less than or equal to the value in the "Low" row are treated as low, by
default, and not actively considered when \code{FAUST} processes the data.
Expression values in a channel greater than or equal to the value in the "High"
row are treated as high, by default, and not actively considered when \code{FAUST}
processes the data.

If the user provides the empty string "", channel bounds will be determined
empirically.

When the user provides either the empty string "" or a single numeric matrix
as the \code{channelBounds} setting, the same channel bounds matrix will apply to
all samples in the experiment. However, if the user is analyzing a dataset
whose analysis supports using the \code{imputationHierarchy} parameter, different
levels of the imputation hierarchy can be assigned distinct channelBounds
matrices. To do this, pass faust a list of 2 by \code{length(activeChannels)}
matrices. The length of the list must equal the number of distinct levels in
the imputation hierarchy. The name of each slot of the list must be a unique
level of the imputation hierarchy. FAUST will then analyze all experimental
units grouped by that level using the supplied channel bounds matrix.}

\item{experimentalUnit}{A character vector specifying the experimental unit
of analysis of samples contained in the gating set. If left as its default
value "", the "name" column in \code{pData(gatingSet)} will be used as the
experimental unit, leading to \code{FAUST} analyzing each sample independently.
If modified by the user, the value must match one of the strings in
\code{colnames(pData(gatingSet))}; the corresponding column of the data frame
\code{pData(gatingSet)} will be used to concatenate individual samples into
experimental units for analysis by \code{FAUST}.}

\item{imputationHierarchy}{A character vector specifying the imputation
hierarchy for annotation boundaries computed by FAUST. If left as its default
value "", \code{FAUST} will impose no hierarchy on the data. If modified by the
user, the value must match one of the strings in \code{colnames(pData(gatingSet))};
the corresponding column of the data frame \code{pData(gatingSet)} will
be used to impose the impose the imputation hierarchy: for each selected
marker, experimental units that do not empirical support annotation bondaries
for a marker will first attempt to use other experimental units with the same
\code{imputationHierarchy} coding to impute boundaries. If this is not possible,
annotation boundaries will be imputed usining boundaries from all experimental
units.}

\item{projectPath}{An absolute path on your system that locates all
intermediate data produced by faust. At the location specified by the
projectPath, \code{faust} creates a directory called \code{faustData}, and
subdirectories that contain intermediate data generated by the analysis. The
final output of \code{faust}, an annotated matrix of counts, is produced at
\code{projectPath/faustData/faustCountMatrix.rds}, and can be loaded into R using
the \code{readRDS} function.}

\item{depthScoreThreshold}{A numeric value between 0 and 1 used for marker
selection. \code{faust} uses this parameter in conjunction with the
\code{selectionQuantile} parameter to determine which markers to use for discovery
and annotation. \code{faust} automatically produces a plot
"projectPath/faustData/plotData/scoreLines.pdf" that can be used to help set
this threshold value for an experiment.}

\item{selectionQuantile}{A numeric value between 0 and 1 used for marker
selection. Depth scores are computed for all experimental units in the
experiment. FAUST computes the empirical selectionQuantile  across each
channel: \code{quantile(channelDepthScores,probs=selectionQuantile)}. The
empirical quantile is then compared to the depthScoreThreshold for each
marker. All markers with empirical quantile above the depthScoreThreshold
are used by \code{faust} to discover and annotate cell subsets in the experiment.}

\item{nameOccuranceNum}{The number of times a name has to appear in distinct
SCAMP clusterings to be gated out.}

\item{supervisedList}{A list of lists. The names of list entries correspond
to marker names in the active channels vector to which supervision is
applied. Channels named in this list will have their gate locations modified.

Supported supervision: 'Preference'. Asserts a preference for the number of
annotation boundaries for a targeted marker. If this is selected, FAUST will
attempt to standardize to the preferred number of boundaries across experimental
units if there is empirical data to support the preference.

Example syntax:

supervisedList <- list(\code{Target_Marker} = list(actionType = "Preference", action = c(2)))}

\item{debugFlag}{Boolean value. Set to TRUE to print method status information
to the console or a log file.}

\item{threadNum}{Integer value. Many components of the FAUST method support
multi-threading on a single CPU. Set this parameter to the number of threads
you wish to use.}

\item{seedValue}{Integer value that determines the random seed. Used for
reproducibility.}

\item{drawAnnotationHistograms}{Boolean. Set to TRUE to draw the annotation
boundary locations for selected markers for all samples and all markers. Set
to FALSE to forego the plotting.}

\item{annotationsApproved}{Boolean value. FALSE by default to encourage the
user to review the proposed annotation boundaries. When set to TRUE, indicates
the user wants to use the proposed annotation boundaries to cluster and gate
the experiment. If you want to run the FAUST method totally unsupervised,
set this parameter to true before running the \code{faust} function.}

\item{densitySubSampleThreshold}{Integer value.
Sets the number of cells needed in a clustering collection to sub-sample for density estimation.
NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
in the clustering collection.}

\item{densitySubSampleSize}{Integer value.
The number of cells to sub-sample from a clustering collection for density estimation.
NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
in the clustering collection.}

\item{densitySubSampleIterations}{Integer value.
The number of distinct sub-sampled density estimates to compute. The final gate location is the median
across the sub-sampled densities.
NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
in the clustering collection.}

\item{archDescriptionList}{list containing slot "targetArch".
Default "singleCPU" indicates FAUST will run on a single processor.

FAUST also has preliminary support for dispatching jobs across nodes of a
cluster managed by slurm. This support assumes the "sbatch" command is
available to launch jobs on the cluster.

Also note that the current implementation does not dynamically restart jobs
that fail to launch after sbatch is invoked. In the event a job fails to launch,
the faust call must be interrupted and called again.

\code{faust} attempts to check-point much of the intermediate progress in order to
avoid performing redundant computation.

Set "targetArch" slot to "slurmCluster" to dispatch jobs across a cluster
managed by slurm. When "targetArch" is set to "slurmCluster", the following
slots must be set by the user.

Slot "partitionID": Character string. The name of the partition on which jobs
are run.

Slot "jobPrefix": Character string. This string will prepend all jobs launched
on the slurm cluster. When "squeue" is used to interrogate job state, this
string can be used to identify jobs.

Slot "jobTime"" Character string. This string sets the maximum time a job
launched by faust on the slurm cluster can run. String format follows
'HH:MM:SS'.

Slot "maxNodeNum": Numeric value. The maximum number of nodes you wish to
request on the slurm cluster.

Slot "maxTime": Numeric value. The total amount of time you want to run FAUST
for. When exceeded, the job terminates.

Slot "nodeThreadNum": Character string. The number of threads used by FAUST
on each node.

Slot "sbatchFlags": Character string. This string contains space-delimited
command-line flags to pass to sbatch.}

\item{plottingDevice}{string with device for saving graphical output.
By default it is set to "pdf".}
}
\value{
The \code{faust} function returns a null value on completion. The main
output is the file "projectPath/faustData/faustCountMatrix.rds". The
rownames are \verb{sampleNames(gatingSet)]}

and the column names are the cell populations discovered by the method.
Note that the special cell population "0_0_0_0_0" counts unclassified
cells in the experiment.
}
\description{
This function discovers and annotates cell subsets in experimental cytometry
data stored in a gating set.
}
\examples{

#Please see the vignette "faustIntro" for an introduction on using FAUST.

}
\author{
Evan Greene \href{mailto:egreene@fredhutch.org}{egreene@fredhutch.org}
}
