#' Full Annotation Using Shape-constrained Trees
#'
#' This function can be used as the first step of a FAUST analysis.
#'
#' @param gatingSet The FAUST method requires that experimental cytometry
#' data you wish to analyze is stored in a `GatingSet` data structure. This data
#' structure can be constructed available using the `flowWorkspace` Bioconductor
#' package.
#'
#' @param startingCellPop A character vector specifying the node from the manual
#' gating strategy attached to the `gatingSet` to use for `faust` analysis. The
#' node in the manual gating strategy is, at minimum, asusmed by `faust` to have
#' pre-gated debris and dead cells. For example, the node might identify live
#' lymphocytes in each sample.
#'
#' @param activeChannels A character vector, each entry of which is a marker name
#' to be used in the `faust` analysis. The markers listed in this parameter must
#' **exactly** match the `desc` field of the `parameters` of the `flowFrames` in
#' the `GatingSet. `FAUST` will not run if they do not match exactly.
#'
#' @param channelBounds This parameter accepts three settings: an empty string,
#' a matrix, and a list.
#'
#' The matrix setting: A 2 by `length(activeChannels)` numeric matrix, with
#' `colnames(channelBounds) <- activeChannels` and
#' `rownames(channelBounds) <- c("Low","High")`. Expression values in a channel
#' less than or equal to the value in the "Low" row are treated as low, by
#' default, and not actively considered when `FAUST` processes the data.
#' Expression values in a channel greater than or equal to the value in the "High"
#' row are treated as high, by default, and not actively considered when `FAUST`
#' processes the data.
#'
#' If the user provides the empty string "", channel bounds will be determined
#' empirically.
#'
#' When the user provides either the empty string "" or a single numeric matrix
#' as the `channelBounds` setting, the same channel bounds matrix will apply to
#' all samples in the experiment. However, if the user is analyzing a dataset
#' whose analysis supports using the `imputationHierarchy` parameter, different
#' levels of the imputation hierarchy can be assigned distinct channelBounds
#' matrices. To do this, pass faust a list of 2 by `length(activeChannels)`
#' matrices. The length of the list must equal the number of distinct levels in
#' the imputation hierarchy. The name of each slot of the list must be a unique
#' level of the imputation hierarchy. FAUST will then analyze all experimental
#' units grouped by that level using the supplied channel bounds matrix.
#'
#' @param experimentalUnit A character vector specifying the experimental unit
#' of analysis of samples contained in the gating set. If left as its default
#' value "", the "name" column in `pData(gatingSet)` will be used as the
#' experimental unit, leading to `FAUST` analyzing each sample independently.
#' If modified by the user, the value must match one of the strings in
#' `colnames(pData(gatingSet))`; the corresponding column of the data frame
#' `pData(gatingSet)` will be used to concatenate individual samples into
#' experimental units for analysis by `FAUST`.
#'
#' @param imputationHierarchy A character vector specifying the imputation
#' hierarchy for annotation boundaries computed by FAUST. If left as its default
#' value "", `FAUST` will impose no hierarchy on the data. If modified by the
#' user, the value must match one of the strings in `colnames(pData(gatingSet))`;
#' the corresponding column of the data frame `pData(gatingSet)` will
#' be used to impose the impose the imputation hierarchy: for each selected
#' marker, experimental units that do not empirical support annotation bondaries
#' for a marker will first attempt to use other experimental units with the same
#' `imputationHierarchy` coding to impute boundaries. If this is not possible,
#' annotation boundaries will be imputed usining boundaries from all experimental
#' units.
#'
#' @param projectPath An absolute path on your system that locates all
#' intermediate data produced by faust. At the location specified by the
#' projectPath, `faust` creates a directory called `faustData`, and
#' subdirectories that contain intermediate data generated by the analysis. The
#' final output of `faust`, an annotated matrix of counts, is produced at
#' `projectPath/faustData/faustCountMatrix.rds`, and can be loaded into R using
#' the `readRDS` function.
#'
#' @param depthScoreThreshold A numeric value between 0 and 1 used for marker
#' selection. `faust` uses this parameter in conjunction with the
#' `selectionQuantile` parameter to determine which markers to use for discovery
#' and annotation. `faust` automatically produces a plot
#' "projectPath/faustData/plotData/scoreLines.pdf" that can be used to help set
#' this threshold value for an experiment.
#'
#' @param selectionQuantile A numeric value between 0 and 1 used for marker
#' selection. Depth scores are computed for all experimental units in the
#' experiment. FAUST computes the empirical selectionQuantile  across each
#' channel: `quantile(channelDepthScores,probs=selectionQuantile)`. The
#' empirical quantile is then compared to the depthScoreThreshold for each
#' marker. All markers with empirical quantile above the depthScoreThreshold
#' are used by `faust` to discover and annotate cell subsets in the experiment.
#'
#'
#' @param supervisedList A list of lists. The names of list entries correspond
#' to marker names in the active channels vector to which supervision is
#' applied. Channels named in this list will have their gate locations modified.
#' 
#' Supported supervision: 'Preference'. Asserts a preference for the number of
#' annotation boundaries for a targeted marker. If this is selected, FAUST will
#' attempt to standardize to the preferred number of boundaries across experimental
#' units if there is empirical data to support the preference.
#'
#' Example syntax:
#' 
#' supervisedList <- list(`Target_Marker` = list(actionType = "Preference", action = c(2)))
#'
#' @param debugFlag Boolean value. Set to TRUE to print method status information
#' to the console or a log file.
#'
#' @param threadNum Integer value. Many components of the FAUST method support
#' multi-threading on a single CPU. Set this parameter to the number of threads
#' you wish to use.
#'
#' @param seedValue Integer value that determines the random seed. Used for
#' reproducibility.
#'
#' @param annotationsApproved Boolean value. FALSE by default to encourage the
#' user to review the proposed annotation boundaries. When set to TRUE, indicates
#' the user wants to use the proposed annotation boundaries to cluster and gate
#' the experiment. If you want to run the FAUST method totally unsupervised,
#' set this parameter to true before running the `faust` function.
#'
#' @param drawAnnotationHistograms Boolean. Set to TRUE to draw the annotation
#' boundary locations for selected markers for all samples and all markers. Set
#' to FALSE to forego the plotting.
#' 
#' @param densitySubSampleThreshold Integer value. 
#' Sets the number of cells needed in a clustering collection to sub-sample for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param densitySubSampleSize Integer value.
#' The number of cells to sub-sample from a clustering collection for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param densitySubSampleIterations Integer value.
#' The number of distinct sub-sampled density estimates to compute. The final gate location is the median
#' across the sub-sampled densities.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param archDescriptionList list containing slot "targetArch".
#' Default "singleCPU" indicates FAUST will run on a single processor.
#'
#' FAUST also has preliminary support for dispatching jobs across nodes of a
#' cluster managed by slurm. This support assumes the "sbatch" command is
#' available to launch jobs on the cluster.
#'
#' Also note that the current implementation does not dynamically restart jobs
#' that fail to launch after sbatch is invoked. In the event a job fails to launch,
#' the faust call must be interrupted and called again.
#'
#' `faust` attempts to check-point much of the intermediate progress in order to
#' avoid performing redundant computation.
#'
#' Set "targetArch" slot to "slurmCluster" to dispatch jobs across a cluster
#' managed by slurm. When "targetArch" is set to "slurmCluster", the following
#' slots must be set by the user.
#'
#' Slot "partitionID": Character string. The name of the partition on which jobs
#' are run.
#'
#' Slot "jobPrefix": Character string. This string will prepend all jobs launched
#' on the slurm cluster. When "squeue" is used to interrogate job state, this
#' string can be used to identify jobs.
#'
#' Slot "jobTime"" Character string. This string sets the maximum time a job
#' launched by faust on the slurm cluster can run. String format follows
#' 'HH:MM:SS'.
#'
#' Slot "maxNodeNum": Numeric value. The maximum number of nodes you wish to
#' request on the slurm cluster.
#'
#' Slot "maxTime": Numeric value. The total amount of time you want to run FAUST
#' for. When exceeded, the job terminates.
#'
#' Slot "nodeThreadNum": Character string. The number of threads used by FAUST
#' on each node.
#'
#' Slot "sbatchFlags": Character string. This string contains space-delimited
#' command-line flags to pass to sbatch.
#'
#' @param plottingDevice string with device for saving graphical output.
#' By default it is set to "pdf".
#'
#' @return generateAnnotationThresholds is used to generate standardized
#' annotation thresholds prior to the discovery phase of the FAUST analysis.
#' It will initialize a directory called "faustData" located at the projectPath parameter.
#' It will store intermediate and checkpointing data in this directory.
#' When it concludes, a sub-directory called "faustData/plotData" will be created.
#' This directory will contain diagnostic plots to review before proceeding to the discovery
#' and annotate stage of the FAUST method.
#'
#' @importFrom Biobase AnnotatedDataFrame pData
#' @importFrom flowCore exprs parameters
#' @importFrom flowWorkspace getData sampleNames gh_pop_get_data
#' @importFrom tidyr gather
#' @importFrom stats quantile runif mad median qt sd weighted.mean
#' @importFrom whisker whisker.render
#' @importFrom utils read.table globalVariables
#' @importFrom data.table fwrite
#' @importFrom grDevices nclass.FD
#' @importFrom ggplot2 ggplot aes theme_bw geom_hex geom_vline geom_hline xlab ylab theme ggtitle scale_color_manual scale_linetype_manual geom_histogram geom_line ggsave facet_wrap element_text
#' @importFrom viridis magma viridis
#' @importFrom ggridges geom_density_ridges position_points_jitter
#' @importFrom fdrtool gcmlcm
#'
#' @examples
#'
#' #Please see the vignette "generateThresholds" on using this function.
#'
#' @export
#' @md
generateAnnotationThresholds <- function(gatingSet,
                                         startingCellPop,
                                         activeChannels=flowWorkspace::markernames(gatingSet),
                                         channelBounds="",
                                         experimentalUnit="",
                                         imputationHierarchy="",
                                         projectPath=normalizePath("."),
                                         depthScoreThreshold=0.01,
                                         selectionQuantile=0.50,
                                         supervisedList=NA,
                                         debugFlag=FALSE,
                                         threadNum=1,
                                         seedValue=123,
                                         drawAnnotationHistograms=TRUE,
                                         densitySubSampleThreshold=1e6,
                                         densitySubSampleSize=1e6,
                                         densitySubSampleIterations=1,
                                         archDescriptionList=
                                             list(
                                                 targetArch=c("singleCPU")
                                             ),
                                         annotationsApproved=FALSE,
                                         plottingDevice="pdf"
                                         )
{
    #first, test parameters for validity. stop faust run if invalid settings detected.
    .validateForestParameters(
        activeChannels = activeChannels,
        channelBounds = channelBounds,
        startingCellPop = startingCellPop,
        projectPath = projectPath,
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        debugFlag = debugFlag,
        threadNum = threadNum,
        seedValue = seedValue,
        supervisedList = supervisedList,
        annotationsApproved = annotationsApproved,
        densitySubSampleThreshold = densitySubSampleThreshold,
        densitySubSampleSize = densitySubSampleSize,
        densitySubSampleIterations = densitySubSampleIterations,
        archDescriptionList=archDescriptionList
    )


    #set up the faustData directory for check-pointing/metadata storage.
    .initializeFaustDataDir(
        projectPath = projectPath,
        activeChannels = activeChannels,
        channelBounds = channelBounds,
        startingCellPop = startingCellPop,
        supervisedList=supervisedList
    )

    #construct the analysis map using the metadata stored in the gating set.
    #the analysis map is a data frame that links samples to their experimental unit
    #and their level in the imputation hierarchy.
    .constructAnalysisMap(
        projectPath = projectPath,
        gspData = flowWorkspace::pData(gatingSet),
        sampNames = flowWorkspace::sampleNames(gatingSet),
        experimentalUnit = experimentalUnit,
        imputationHierarchy = imputationHierarchy,
        debugFlag = debugFlag
    )

    #begin method processing. copy data to projectPath from gatingSet.
    if (debugFlag) print("Begin data extraction.")
    .extractDataFromGS(
        gs = gatingSet,
        activeChannels = activeChannels,
        startingCellPop = startingCellPop,
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    #make sure the channel bounds conform to internal requirements
    #test to see if there have been changes between faust runs.
    .processChannelBounds(
        samplesInExp = flowWorkspace::sampleNames(gatingSet),
        projectPath = projectPath,
        channelBounds = channelBounds,
        debugFlag = debugFlag
    )

    if (debugFlag) print("Making restriction matrices.")
    .makeRestrictionMatrices(
        samplesInExp = flowWorkspace::sampleNames(gatingSet),
        channelBounds = channelBounds,
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    #accumulate data into the experimental units.
    if (debugFlag) print("Collecting data into experimental units.")
    .prepareExperimentalUnits(projectPath = projectPath)


    #
    #ALL uses of startingCellPop must be updated to sanitizedCellPopStr
    #
    #start the annotation process
    if (!file.exists(file.path(normalizePath(projectPath),
                               "faustData",
                               "metaData",
                               "bigForestDone.rds"))) {
        #in large experiments, this can be a costly step without sub-sampling.
        #often we will want to supervise the results after growing the forest,
        #so only grow it on an as-need basis
        .growAnnForest(
            activeChannels = activeChannels,
            debugFlag = debugFlag,
            threadNum = threadNum,
            seedValue = seedValue,
            projectPath = projectPath,
            densitySubSampleThreshold = densitySubSampleThreshold,
            densitySubSampleSize = densitySubSampleSize,
            densitySubSampleIterations = densitySubSampleIterations,
            archDescriptionList = archDescriptionList
        )
        bigForestDone <- TRUE
        saveRDS(bigForestDone,
                file.path(normalizePath(projectPath),
                          "faustData",
                          "metaData",
                          "bigForestDone.rds"))
    }

    if (debugFlag) print("Selecting standard set of channels across experiment using depth score.")
    .selectChannels(
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        projectPath = projectPath
    )
    #selC no longer returned
    #must map to reads from metaData/initSelC.rds

    if (debugFlag) print("Reconciling annotation boundaries across experiment.")
    .reconcileAnnotationBoundaries(
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    .superviseReconciliation(
        projectPath = projectPath,
        debugFlag = debugFlag
    )


    if (debugFlag) print("Writing annotation matrices to file.")
    .mkAnnMats(
        projectPath = projectPath
    )

    if (debugFlag) print("Generating depth score plot.")
    .plotScoreLines(
        projectPath = projectPath,
        depthScoreThreshold = depthScoreThreshold,
        selectionQuantile = selectionQuantile,
        plottingDevice = plottingDevice
    )

    if (debugFlag) print("Generating marker boundary histograms.")
    .plotMarkerHistograms(
        projectPath = projectPath,
        plottingDevice = plottingDevice
    )

    if (drawAnnotationHistograms) {
        if (debugFlag) print("Generating annotation boundary histograms.")
        .plotSampleHistograms(
            projectPath = projectPath,
            plottingDevice=plottingDevice
        )
    }

    if (!annotationsApproved) {
        print("********************************************************")
        print("FAUST has selected a subset of the marker panel using")
        print("the depth score at the specified selection quantile.")
        print("Annotation thresholds have been generated for all selected markers.")
        print(paste0("Plots have been written to file in the directory ",
                     paste0(file.path(normalizePath(projectPath),
                                      "faustData",
                                      "plotData"))))
        print("")
        print("Review these plots to ensure all desired markers have been selected.")
        print("If too many/too few markers have been selected, modify the parameters")
        print("depthScoreThreshold and selectionQuantile.")
        print("")
        print(paste0("Also review the annotation thresholds displayed on the sample-level histograms in",
                     paste0(file.path(normalizePath(projectPath),
                                      "faustData",
                                      "plotData"))))
        print("If you wish to modify the placement of the annotation thresholds,")
        print("change the parameters supervisedList.")
        print("")
        print("Changing the Low/High values in the channelBounds matrix will also affect")
        print("the placement of annotation thresholds. It is the most effective way to directly modify")
        print("their placement. However, when you modify the Low/High values in the channelBounds matrix,")
        print("the FAUST method will regrow the entire annotation forest.")
        print("")
        print("Once you are satisfied with the annotation boundary")
        print("placement, set the parameter")
        print("annotationsApproved=TRUE in the faust R function.")
        print("FAUST will then conduct phenotype discovery and ")
        print("annotation on each experimental unit.")
        print("********************************************************")
    }

    else {
        saveRDS(annotationsApproved,
                file.path(normalizePath(projectPath),
                          "faustData",
                          "metaData",
                          "annotationsApproved.rds"))
    }
    return()
}
