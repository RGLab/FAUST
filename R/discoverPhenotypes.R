#' Full Annotation Using Shape-constrained Trees
#'
#' This function is run after running and tuning generateAnnotationThresholds
#' in order to discover and annotate cell subsets in a cytometry experiment.
#'
#' @param gatingSet The FAUST method requires that experimental cytometry
#' data you wish to analyze is stored in a `GatingSet` data structure. This data
#' structure can be constructed available using the `flowWorkspace` Bioconductor
#' package.
#'
#' @param projectPath An absolute path on your system that locates all
#' intermediate data produced by faust. At the location specified by the
#' projectPath, `faust` creates a directory called `faustData`, and
#' subdirectories that contain intermediate data generated by the analysis. The
#' final output of `faust`, an annotated matrix of counts, is produced at
#' `projectPath/faustData/faustCountMatrix.rds`, and can be loaded into R using
#' the `readRDS` function.
#'
#' @param nameOccurenceNum The number of times a name has to appear in distinct
#' SCAMP clusterings to be gated out.
#'
#' @param debugFlag Boolean value. Set to TRUE to print method status information
#' to the console or a log file.
#'
#' @param threadNum Integer value. Many components of the FAUST method support
#' multi-threading on a single CPU. Set this parameter to the number of threads
#' you wish to use.
#'
#' @param seedValue Integer value that determines the random seed. Used for
#' reproducibility.
#'
#' @param densitySubSampleThreshold Integer value. 
#' Sets the number of cells needed in a clustering collection to sub-sample for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param densitySubSampleSize Integer value.
#' The number of cells to sub-sample from a clustering collection for density estimation.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param densitySubSampleIterations Integer value.
#' The number of distinct sub-sampled density estimates to compute. The final gate location is the median
#' across the sub-sampled densities.
#' NOTE: sub-sampling only occurs for density estimation. The dip test is computed on all cells
#' in the clustering collection. 
#' 
#' @param archDescriptionList list containing slot "targetArch".
#' Default "singleCPU" indicates FAUST will run on a single processor.
#'
#' FAUST also has preliminary support for dispatching jobs across nodes of a
#' cluster managed by slurm. This support assumes the "sbatch" command is
#' available to launch jobs on the cluster.
#'
#' Also note that the current implementation does not dynamically restart jobs
#' that fail to launch after sbatch is invoked. In the event a job fails to launch,
#' the faust call must be interrupted and called again.
#'
#' `faust` attempts to check-point much of the intermediate progress in order to
#' avoid performing redundant computation.
#'
#' Set "targetArch" slot to "slurmCluster" to dispatch jobs across a cluster
#' managed by slurm. When "targetArch" is set to "slurmCluster", the following
#' slots must be set by the user.
#'
#' Slot "partitionID": Character string. The name of the partition on which jobs
#' are run.
#'
#' Slot "jobPrefix": Character string. This string will prepend all jobs launched
#' on the slurm cluster. When "squeue" is used to interrogate job state, this
#' string can be used to identify jobs.
#'
#' Slot "jobTime"" Character string. This string sets the maximum time a job
#' launched by faust on the slurm cluster can run. String format follows
#' 'HH:MM:SS'.
#'
#' Slot "maxNodeNum": Numeric value. The maximum number of nodes you wish to
#' request on the slurm cluster.
#'
#' Slot "maxTime": Numeric value. The total amount of time you want to run FAUST
#' for. When exceeded, the job terminates.
#'
#' Slot "nodeThreadNum": Character string. The number of threads used by FAUST
#' on each node.
#'
#' Slot "sbatchFlags": Character string. This string contains space-delimited
#' command-line flags to pass to sbatch.
#'
#' @param plottingDevice string with device for saving graphical output.
#' By default it is set to "pdf".
#'
#' @return `discoverPhenotypes` returns a null value on completion. The main
#' output is the file "projectPath/faustData/faustCountMatrix.rds". The
#' rownames are `sampleNames(gatingSet)]`
#' and the column names are the cell populations discovered by `faust`.
#' Note that the special cell population "0_0_0_0_0" counts unclassified
#' cells in the experiment.
#'
#' @importFrom scamp scamp
#' @importFrom Biobase AnnotatedDataFrame pData
#' @importFrom flowCore exprs parameters
#' @importFrom flowWorkspace getData sampleNames gh_pop_get_data
#' @importFrom tidyr gather
#' @importFrom stats quantile runif mad median qt sd weighted.mean
#' @importFrom whisker whisker.render
#' @importFrom utils read.table globalVariables
#' @importFrom data.table fwrite
#' @importFrom grDevices nclass.FD
#' @importFrom ggplot2 ggplot aes theme_bw geom_hex geom_vline geom_hline xlab ylab theme ggtitle scale_color_manual scale_linetype_manual geom_histogram geom_line ggsave facet_wrap element_text
#' @importFrom viridis magma viridis
#' @importFrom ggridges geom_density_ridges position_points_jitter
#' @importFrom fdrtool gcmlcm
#' 
#' @examples
#'
#' #Please see the vignette "discoverPhenotypes" for an introduction on using FAUST.
#'
#' @export
#' @md
discoverPhenotypes <- function(gatingSet,
                               projectPath=normalizePath("."),
                               nameOccurenceNum=0,
                               debugFlag=FALSE,
                               threadNum=1,
                               seedValue=123,
                               densitySubSampleThreshold=1e6,
                               densitySubSampleSize=1e6,
                               densitySubSampleIterations=1,
                               archDescriptionList=
                                   list(
                                       targetArch=c("singleCPU")
                                   ),
                               plottingDevice="pdf"
                               )
{
    if (!dir.exists(file.path(projectPath,"faustData"))) {
        print("The faustData directory is not detected at the projectPath")
        print("setting. This indicates generateAnnotationThresholds has")
        print("not yet been run/tuned. Do this before running discoverPhenotypes")
        stop("and then update the projectPath in the discoverPhenotypes call.")
    }

    #test parameters for validity. stop faust run if invalid settings detected.
    .validateDiscoveryParameters(
        projectPath = projectPath,
        debugFlag = debugFlag,
        threadNum = threadNum,
        seedValue = seedValue,
        densitySubSampleThreshold=densitySubSampleThreshold,
        densitySubSampleSize=densitySubSampleSize,
        densitySubSampleIterations=densitySubSampleIterations,
        archDescriptionList=archDescriptionList
    )

    if (debugFlag) print("Discovering phenotypes across experimental units.")
    .clusterExpUnitsWithScamp(
        projectPath = projectPath,
        nameOccurenceNum = nameOccurenceNum,
        debugFlag = debugFlag,
        threadNum = threadNum,
        seedValue = seedValue,
        densitySubSampleThreshold = densitySubSampleThreshold,
        densitySubSampleSize = densitySubSampleSize,
        densitySubSampleIterations = densitySubSampleIterations,
        archDescriptionList = archDescriptionList
    )

    .plotPhenotypeFilter(
        projectPath=projectPath,
        nameOccurenceNum=nameOccurenceNum,
        plottingDevice=plottingDevice
    )

    if (debugFlag) print("Gating populations.")
    .gateScampClusters(
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    if (debugFlag) print("Generating faust count matrix.")
    .getFaustCountMatrix(
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    if (debugFlag) print("Gating all populations.")
    .gateAllScampClusters(
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    if (debugFlag) print("Generating exhaustive faust count matrix.")
    .getExhaustiveFaustCountMatrix(
        projectPath = projectPath,
        debugFlag = debugFlag
    )

    return()
}
